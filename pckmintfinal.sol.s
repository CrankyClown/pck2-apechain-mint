/*

@@@@@@@@@@@@@@@@@@@@@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@@@@@
@@@@@@@@@@@@&&&&&&&&########################&&&&#########BBBB########################################&&&&&&&&&@@@@@@@@
@@@@@@@@@@&&&&&#&##BBBGGBBBBGG5YJJ?JJY5PB###########BPY7!!!!!!7?Y5GBBBBBBBGY?77777JJ???YPBBBB#BBGGBBBBBB#&&&&&&@@@@@@@
@@@@@@@@&&&&###GY7!!!!!!!!!!!!7JYY55YJ?!~!YGBBBBPY?!~~?5BBGGGGP5J7!~!7YPGJ:!5PGGPPYY555J~^YG57~!!!!!!!!!~JB##&&&&@@@@@
@@@@@@@&&&&##B7:7PGGGGGGGGGGGGG5YJJJJYPB#5!:?PJ~~7YPBBGY?!~~!7?Y5GBBG5!^~ J@#J!!7?JJJ?5&@!.!.?BBGGGGGGG#G^^G##&&&@@@@@
@@@@@@@&&&##B~:#@P7!~~~~~~~~~~~^^^^^^^~~?G@G^.^P&B5?7~~^^~~~~~^^^~~!?P&#7.#@G!^~~^^^^~Y&@J 7B&G7~~~!~~?#@G J##&&&&@@@@
@@@@@@&&&###G J@&5!~~~~~~~~~~~~~~~~~~~~~^~5&&J&&Y~~~~~~~~~~~~~~~~~~~^~7G@B&@G!~~~~~~~~Y&@G##P7~~~~~~^!G@@7.G###&&&@@@@
@@@@@@&&&##BB~.B@#J~~~~~~~~~~!~~~~~~~~~~~~~Y&@@5~~~~~~~~~~~~~~~~~~~~~~~!P@@@P!~~~~~~~~?#@&P!~~~~~~~~~5&@P J####&&&@@@@
@@@@@@&&&##BB~:&@P~~~~~~~~YB##B?~~~~~~~~~~~~?G#?~~~~~~~~~5BJ7B&J~~~~~~~~?#@@P!~~~~~~7G#@#Y~~~~~~~!7!?#@#.~BB##&&&&@@@@
@@@@@@&&&###B^:@@BJ~~~~~~~J#@@&J~!?!~~~~~~~~~!Y?~~~~~~~~~7GY!G&Y~~~~~~~~7B@#J~~~~~~~7B@#J~~~~~~~!P#YJ&@J 5BB##&&&@@@@@
@@@@@@&&&&##B5.!@@#Y!~~~~~~!?P#J?B&5~~~~~~~~~~!7~~~~~~~JPPB5!5&Y~~~~~~~~J&@G!~~~~~~~J&&J~~~~~~~~7B#??#@P Y###&&&&@@@@@
@@@@@@@&&&##BBP:^&@B?~~~~~~~?B@&&@@G!~~~~~~~~!J?~~~~~~~?#@@&#&@5!~!?7!!~J&@G7~~~~~~~?PY!~!!!~!YYJB@B#@@J 5###&&&@@@@@@
@@@@@@@&&&###BBY P@#?~!!!!!~?B@&B@&5!!!!!!!!JB#J~!!!!!!!P@@#B&@@G7?##BBJY#@#?~!!!!!!~~!!!!!!~J&@@@&##G?.?###&&&@@@@@@@
@@@@@@@@&&&##BB5 5@#J!!!!!!!5&@&#&57!!!!!!!?B@&Y!!!!!!!J#@B.:.P@&GG@@@@@@@@B?!!!!!!!!!!!!!!!!?B@#7^~!!?G###&&&&@@@@@@@
@@@@@@@@&&&##BBY P@B?!!!!!!!7Y55Y7!!!!!!!!!J&@&Y!!!!!!!P@@! J^.5&@@&5^7J5@@5!!!!!!!!!!!!!!!!!?B@B !GGB####&&&&@@@@@@@@
@@@@@@@@&&&##BB~.&@P7!!!!!!!!!!!!!!!!!!!!!JB@@@5!!!!!!!?P&B~.J?^^~~^^7! Y@#?!!!!!!!!!!!!!!!!!J#@5 YGGBB##&&&&@@@@@@@@@
@@@@@@@@&&&&##B!.#@#57!!!!!!!!!!!!!!!!!!JG&@&@@57!!!!!!!75@@^.~~~~^~~~^^#@B?!!!!!!!7YBP7!!!!!7P@&^^GBB###&&&@@@@@@@@@@
@@@@@@@@@&&&##BG^^B@&57!!!!!!7J5PPPPPY7?B@@J!@@57!!!!!!!!Y&@7.5#BBBBGBBB#&G7!77777!75&B?!7777!7G@B !BB###&&&@@@@@@@@@@
@@@@@@@@@&&&##BBG^:&@G?!777777G@@@@@@@BG&@5 !@&Y7777777!!J#@YJ@&Y7??7??775Y77777777!?B#J!77777!Y&@7.PBB##&&&@@@@@@@@@@
@@@@@@@@@&&&###BBJ G@B?7777777Y&@Y::?B&&#5: G@G?7777777YG#@@?7@&Y77777777J77777777775&@G?777777?B@P JBB###&&&@@@@@@@@@
@@@@@@@@@&&&&##BBJ P@BJ7777777Y&@J ?!~~~~!.:@@B5?777777JB@@! Y@#J777777?Y?7777777775&@@@P77777775&@!.5BB##&&&&@@@@@@@@
@@@@@@@@@@&&&##BB^:&@5?77777775&@7 YPP5PPP? Y@@P?7777775&@#:^&@P?777777JBG?7777777JB@&#@#J777777?5#@?.JBB##&&&@@@@@@@@
@@@@@@@@@@&&&###P J@&577?????7?P&#!.JPPPPPP~.&@BJ7?????5##BB#&P?7?????7?GP????????5&@J7@@P????????JB@Y ?B###&&&@@@@@@@
@@@@@@@@@@&&&###B~:&@&5?????????Y&@? 5GGGGG! #@BYJ??????????J??????????5BY????????P@@^ G@#Y????????JB@5 Y###&&&@@@@@@@
@@@@@@@@@@&&&&##BG^^B@&5???????JP&@5 YGGGGBY J@@@BY?????????????????J5B@&Y????????Y#@? ?@&Y?????????P@@:^B##&&&&@@@@@@
@@@@@@@@@@@&&&##BBG.!@@5???????J5&@7.PBBBBBBJ:~Y@@#?????????????????&@@@@5??J???JYP&@5 !@@GYJ??????JP@@^^B##&&&&@@@@@@
@@@@@@@@@@@&&&&##BB:~@@P????????G@@J !77!!!!7!^:7B@@&??????????????@@GJ@@BY5?????@@@P:  J&@&????????@@B.!###&&&@@@@@@@
@@@@@@@@@@@@&&&####7 B@&55&@&5YG@@#YYYYYJJJJJJJJJJYB@@&@B5P@@#G#@#YYY??P@@&&#YJP@@#PJJ5Y?5@@&B&PJ5&@B!:7B###&&&@@@@@@@
@@@@@@@@@@@@&&&###B^:B@@@@@BYJ5&@?!!777???JJJJJJYYP&@@@@@@@@@@@@#YYYYYYB@@@&P5B@@?!!!!!!^7&&@@5Y5&@J 5####&&&@@@@@@@@@

Developer: crankydev.eth
*/
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "erc721a/contracts/ERC721A.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/common/ERC2981.sol";

contract PCKMINT is ERC721A, Ownable, ReentrancyGuard, ERC2981 {
    using Strings for uint256;

    address public immutable developer;
    uint256 public constant MAX_SUPPLY = 2000;
    uint256 public constant PACK_SIZE = 3;
    uint256 public constant PHASE_DURATION = 1 hours;
    uint96 private constant DEFAULT_ROYALTY_FEE = 500;
    uint256 private constant DEV_SHARE = 25;
    uint256 private constant MAX_WHITELIST_BATCH = 100;
    
    enum MintPhase { CLOSED, GTD, FCFS, PUBLIC }
    MintPhase public currentPhase = MintPhase.CLOSED;
    
    uint256 public packPrice = 25 ether;
    uint256 public publicPackPrice = 30 ether;
    
    string private _baseTokenURI;
    string public placeholderURI;
    bool public revealed;
    bool public saleActive;
    bool public paused;
    
    uint256 public phaseStartTimestamp;
    
    mapping(address => uint256) public whitelistMints;
    mapping(address => uint256) public publicMints;
    mapping(address => bool) private _whitelistLookup;
    address[] private _whitelist;

    event PhaseChanged(MintPhase newPhase);
    event PackMinted(address indexed minter, uint256 quantity);
    event RoyaltySet(address receiver, uint96 feeNumerator);
    event RevealStateChanged(bool revealed);
    event PauseStateChanged(bool paused);
    event WhitelistUpdated(uint256 numberOfAddresses);
    event WhitelistAdded(uint256 numberOfAddresses);
    event BaseURIUpdated(string newBaseURI);
    event FundsWithdrawn(address recipient, uint256 amount);
    event PricesUpdated(uint256 newPackPrice, uint256 newPublicPackPrice);

    constructor(string memory initialBaseURI, string memory _placeholderURI, address _developer) 
        ERC721A("Pop Culture Kids", "PCK") 
        Ownable(msg.sender) 
    {
        require(_developer != address(0), "Invalid developer address");
        developer = _developer;
        _baseTokenURI = initialBaseURI;
        placeholderURI = _placeholderURI;
        _setDefaultRoyalty(msg.sender, DEFAULT_ROYALTY_FEE);
        
       
        _mint(msg.sender, 1);
    }

   
    function setPrices(uint256 _packPrice, uint256 _publicPackPrice) external onlyOwner {
        packPrice = _packPrice;
        publicPackPrice = _publicPackPrice;
        emit PricesUpdated(_packPrice, _publicPackPrice);
    }

    
    modifier whenNotPaused() {
        require(!paused, "Contract is paused");
        _;
    }

    function _startTokenId() internal pure override returns (uint256) {
        return 1;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseTokenURI;
    }

    function supportsInterface(bytes4 interfaceId) 
        public 
        view 
        override(ERC721A, ERC2981) 
        returns (bool) 
    {
        return 
            interfaceId == 0x80ac58cd || 
            interfaceId == 0x5b5e139f || 
            super.supportsInterface(interfaceId);
    }

    function addWhitelistReset(address[] calldata addresses) external onlyOwner {
        require(addresses.length <= MAX_WHITELIST_BATCH, "Exceeds max batch size");
        uint256 addedCount = 0;
        for (uint i = 0; i < addresses.length; i++) {
            if (!_whitelistLookup[addresses[i]]) {
                _whitelistLookup[addresses[i]] = true;
                _whitelist.push(addresses[i]);
                addedCount++;
            }
        }
        emit WhitelistAdded(addedCount);
    }

    function resetWhitelistMints(address[] calldata addresses) external onlyOwner {
        require(addresses.length <= MAX_WHITELIST_BATCH, "Exceeds max batch size");
        for (uint i = 0; i < addresses.length; i++) {
            whitelistMints[addresses[i]] = 0;
        }
    }

    function setWhitelist(address[] calldata addresses) external onlyOwner {
        require(addresses.length <= MAX_WHITELIST_BATCH, "Exceeds max batch size");
        for (uint i = 0; i < _whitelist.length; i++) {
            _whitelistLookup[_whitelist[i]] = false;
        }
        _whitelist = addresses;
        for (uint i = 0; i < addresses.length; i++) {
            _whitelistLookup[addresses[i]] = true;
        }
        emit WhitelistUpdated(addresses.length);
    }

    function isWhitelisted(address _address) public view returns (bool) {
        return _whitelistLookup[_address];
    }

    function getWhitelist() public view returns (address[] memory) {
        return _whitelist;
    }

    function setPaused(bool _paused) external onlyOwner {
        paused = _paused;
        emit PauseStateChanged(_paused);
    }

    function ownerMint(uint256 amount, address to) external onlyOwner whenNotPaused {
        require(totalSupply() + amount <= MAX_SUPPLY, "Exceeds max supply");
        _mint(to, amount);
        emit PackMinted(to, amount);
    }

    function mintPack() external payable nonReentrant whenNotPaused {
        require(saleActive, "Sale not active");
        checkPhaseTransition();
        require(totalSupply() + PACK_SIZE <= MAX_SUPPLY, "Max supply reached");

        if (msg.sender != owner()) {
            uint256 price = currentPhase == MintPhase.PUBLIC ? publicPackPrice : packPrice;
            require(msg.value >= price, "Insufficient payment");
        }

        if (currentPhase == MintPhase.GTD) {
            if (msg.sender != owner()) {
                require(isWhitelisted(msg.sender), "Not whitelisted");
                require(whitelistMints[msg.sender] == 0, "Already minted in GTD");
                whitelistMints[msg.sender] = PACK_SIZE;
            }
        } else {
            if (msg.sender != owner()) {
                uint256 maxAllowed = currentPhase == MintPhase.FCFS ? PACK_SIZE * 2 : PACK_SIZE * 5;
                require(publicMints[msg.sender] + PACK_SIZE <= maxAllowed, "Wallet limit exceeded");
                publicMints[msg.sender] += PACK_SIZE;
            }
        }

        _mint(msg.sender, PACK_SIZE);
        emit PackMinted(msg.sender, PACK_SIZE);
    }

    function startMinting() external onlyOwner {
        require(currentPhase == MintPhase.CLOSED, "Minting already started");
        currentPhase = MintPhase.GTD;
        saleActive = true;
        phaseStartTimestamp = block.timestamp;
        emit PhaseChanged(MintPhase.GTD);
    }

    function checkPhaseTransition() public {
        if (currentPhase == MintPhase.CLOSED) return;
        uint256 timeElapsed = block.timestamp - phaseStartTimestamp;
        if (currentPhase == MintPhase.GTD && timeElapsed >= PHASE_DURATION) {
            currentPhase = MintPhase.FCFS;
            phaseStartTimestamp = block.timestamp;
            emit PhaseChanged(MintPhase.FCFS);
        } else if (currentPhase == MintPhase.FCFS && timeElapsed >= PHASE_DURATION) {
            currentPhase = MintPhase.PUBLIC;
            phaseStartTimestamp = block.timestamp;
            emit PhaseChanged(MintPhase.PUBLIC);
        }
    }

    function timeUntilNextPhase() public view returns (uint256) {
        if (currentPhase == MintPhase.CLOSED || currentPhase == MintPhase.PUBLIC) return 0;
        uint256 timeElapsed = block.timestamp - phaseStartTimestamp;
        return timeElapsed >= PHASE_DURATION ? 0 : PHASE_DURATION - timeElapsed;
    }

    function reveal(string calldata baseURI) external onlyOwner {
        revealed = true;
        _baseTokenURI = baseURI;
        emit RevealStateChanged(true);
    }

    function setBaseURI(string calldata baseURI) external onlyOwner {
        _baseTokenURI = baseURI;
        emit BaseURIUpdated(baseURI);
    }

    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "Nonexistent token");
        return revealed ? string(abi.encodePacked(_baseTokenURI, tokenId.toString(), ".json")) : placeholderURI;
    }

    function setDefaultRoyalty(address receiver, uint96 feeNumerator) external onlyOwner {
        _setDefaultRoyalty(receiver, feeNumerator);
        emit RoyaltySet(receiver, feeNumerator);
    }
    
    function withdraw() external nonReentrant {
        require(msg.sender == owner() || msg.sender == developer, "Not authorized");
        uint256 balance = address(this).balance;
        (bool devSent, ) = payable(developer).call{value: balance * DEV_SHARE / 100}("");
        require(devSent, "Dev payment failed");
        (bool ownerSent, ) = payable(owner()).call{value: balance - (balance * DEV_SHARE / 100)}("");
        require(ownerSent, "Owner payment failed");
    }
}